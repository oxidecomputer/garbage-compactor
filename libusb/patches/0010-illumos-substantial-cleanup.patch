From 260c91d42a11605033068a2a91b5924424392f7d Mon Sep 17 00:00:00 2001
From: "Joshua M. Clulow" <josh@sysmgr.org>
Date: Thu, 28 Mar 2024 17:16:56 -0700
Subject: [PATCH 10/11] illumos: substantial cleanup

---
 libusb/os/illumos_usb.c | 1030 +++++++++++++++++++++++----------------
 libusb/os/illumos_usb.h |   73 ++-
 2 files changed, 658 insertions(+), 445 deletions(-)

diff --git a/libusb/os/illumos_usb.c b/libusb/os/illumos_usb.c
index d7228ca6..3c2c9365 100644
--- a/libusb/os/illumos_usb.c
+++ b/libusb/os/illumos_usb.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2016, Oracle and/or its affiliates.
- * Copyright 2022 Oxide Computer Company
+ * Copyright 2024 Oxide Computer Company
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -41,10 +41,21 @@
 #include "libusbi.h"
 #include "illumos_usb.h"
 
-#define	UPDATEDRV_PATH	"/usr/sbin/update_drv"
-#define	UPDATEDRV	"update_drv"
+#define	DEVICES_PREFIX	"/devices"
 
-#define	DEFAULT_LISTSIZE	6
+#if !defined(ARRAY_SIZE)
+#define	ARRAY_SIZE(x)	(sizeof (x) / sizeof (x[0]))
+#endif
+
+struct {
+	const char *name;
+	enum libusb_speed speed;
+} illumos_speed_props[] = {
+	{ .name = "low-speed",		.speed = LIBUSB_SPEED_LOW },
+	{ .name = "high-speed",		.speed = LIBUSB_SPEED_HIGH },
+	{ .name = "full-speed",		.speed = LIBUSB_SPEED_FULL },
+	{ .name = "super-speed",	.speed = LIBUSB_SPEED_SUPER },
+};
 
 /*
  * Backend functions
@@ -69,67 +80,121 @@ static int illumos_submit_transfer(struct usbi_transfer *);
 static int illumos_cancel_transfer(struct usbi_transfer *);
 static int illumos_handle_transfer_completion(struct usbi_transfer *);
 static int illumos_kernel_driver_active(struct libusb_device_handle *, uint8_t);
-static int illumos_usb_open_ep0(illumos_dev_handle_priv_t *hpriv,
-    illumos_dev_priv_t *dpriv);
+static int illumos_usb_open_ep0(struct libusb_context *,
+    illumos_dev_handle_priv_t *ihp, illumos_dev_priv_t *idp);
+
+static void
+illumos_ensure_closed(struct libusb_context *ctx, int *fd)
+{
+	if (*fd < 0) {
+		return;
+	}
+
+	if (close(*fd) != 0) {
+		usbi_err(ctx, "close fd %d failed: errno %d", *fd, errno);
+	}
+	*fd = -1;
+}
 
 static int
-illumos_get_link(di_devlink_t devlink, void *arg)
+illumos_gdl_find_ugenpath_walk(di_devlink_t devlink, void *arg)
 {
-	walk_link_t *larg = (walk_link_t *)arg;
-	const char *p;
-	const char *q;
-
-	if (larg->path) {
-		char *content = (char *)di_devlink_content(devlink);
-		char *start = strstr(content, "/devices/");
-		start += strlen("/devices");
-		usbi_dbg(NULL, "%s", start);
-
-		/* line content must have minor node */
-		if (start == NULL ||
-		    strncmp(start, larg->path, larg->len) != 0 ||
-		    start[larg->len] != ':') {
-			return (DI_WALK_CONTINUE);
-		}
+	struct libusb_device *dev = arg;
+	illumos_dev_priv_t *idp = usbi_get_device_priv(dev);
+
+	const char *content = di_devlink_content(devlink);
+	if (content == NULL) {
+		return (DI_WALK_CONTINUE);
+	}
+
+	usbi_dbg(DEVICE_CTX(dev), "link content: %s", content);
+
+	/*
+	 * Links from /dev are relative links back up out and down into
+	 * the parallel /devices tree.  Strip the prefix off so that
+	 * our path is anchored directly below /devices:
+	 */
+	const char *start = strstr(content, DEVICES_PREFIX);
+	if (start == NULL) {
+		return (DI_WALK_CONTINUE);
+	}
+	start += strlen(DEVICES_PREFIX);
+	if (start[0] != '/') {
+		return (DI_WALK_CONTINUE);
+	}
+
+	/*
+	 * Make sure that this link targets the same /devices path as the one
+	 * we were passed, and that it has a minor node suffix (after the
+	 * separating colon):
+	 */
+	size_t len = strlen(idp->idp_physpath);
+	if (strncmp(start, idp->idp_physpath, len) != 0 || start[len] != ':') {
+		return (DI_WALK_CONTINUE);
 	}
 
-	p = di_devlink_path(devlink);
-	q = strrchr(p, '/');
-	usbi_dbg(NULL, "%s", q);
+	/*
+	 * Get the link name; e.g., "/dev/usb/483.3754/0/cntrl0":
+	 */
+	const char *p = di_devlink_path(devlink);
+	if (p == NULL) {
+		return (DI_WALK_CONTINUE);
+	}
 
-	*(larg->linkpp) = strndup(p, strlen(p) - strlen(q));
+	usbi_dbg(DEVICE_CTX(dev), "link path: %s", p);
+
+	/*
+	 * Trim out the last path component to get the containing directory:
+	 */
+	const char *q = strrchr(p, '/');
+	if (q == NULL || (idp->idp_ugenpath = strndup(p, q - p)) == NULL) {
+		return (DI_WALK_CONTINUE);
+	}
 
 	return (DI_WALK_TERMINATE);
 }
 
-
+/*
+ * Given a device with a base /devices path (no minor node suffix) locate the
+ * /dev directory that contains the ugen(4D) device nodes; e.g.,
+ * "/dev/usb/483.3754/0".  We do this by walking devlinks to look for one that
+ * targets a minor node for that /devices path.
+ */
 static int
-illumos_physpath_to_devlink(
-    const char *node_path, const char *match, char **link_path)
+illumos_gdl_find_ugenpath(illumos_get_device_list_t *gdl,
+    struct libusb_device *dev)
 {
-	walk_link_t larg;
-	di_devlink_handle_t hdl;
+	illumos_dev_priv_t *idp = usbi_get_device_priv(dev);
 
-	*link_path = NULL;
-	larg.linkpp = link_path;
-	if ((hdl = di_devlink_init(NULL, 0)) == NULL) {
-		usbi_dbg(NULL, "di_devlink_init failure");
-		return (-1);
+	if (idp->idp_ugenpath != NULL) {
+		free(idp->idp_ugenpath);
+		idp->idp_ugenpath = NULL;
 	}
 
-	larg.len = strlen(node_path);
-	larg.path = (char *)node_path;
-
-	(void) di_devlink_walk(hdl, match, NULL, DI_PRIMARY_LINK,
-	    (void *)&larg, illumos_get_link);
+	/*
+	 * We only wish to consider /dev links for our vendor and product ID:
+	 */
+	char match[PATH_MAX];
+	(void) snprintf(match, sizeof (match), "^usb/%x.%x",
+	    dev->device_descriptor.idVendor,
+	    dev->device_descriptor.idProduct);
+	usbi_dbg(DEVICE_CTX(dev), "/dev match regex is \"%s\"", match);
 
-	(void) di_devlink_fini(&hdl);
+	if (di_devlink_walk(gdl->gdl_devlink, match, NULL, DI_PRIMARY_LINK,
+	    dev, illumos_gdl_find_ugenpath_walk) != 0) {
+		usbi_err(DEVICE_CTX(dev), "di_devlink_walk() failed: "
+		    "errno %d (%s)", errno, strerror(errno));
+		return (-1);
+	}
 
-	if (*link_path == NULL) {
-		usbi_dbg(NULL, "there is no devlink for this path");
+	if (idp->idp_ugenpath == NULL) {
+		usbi_err(DEVICE_CTX(dev), "ugen path not found for "
+		    "device (match \"%s\", physpath \"%s\")", match,
+		    idp->idp_physpath);
 		return (-1);
 	}
 
+	usbi_dbg(DEVICE_CTX(dev), "selected ugen path: %s", idp->idp_ugenpath);
 	return (0);
 }
 
@@ -137,13 +202,26 @@ static int
 illumos_kernel_driver_active(struct libusb_device_handle *dev_handle,
     uint8_t interface)
 {
-	illumos_dev_priv_t *dpriv = usbi_get_device_priv(dev_handle->dev);
+	illumos_dev_priv_t *idp = usbi_get_device_priv(dev_handle->dev);
 
 	UNUSED(interface);
 
-	usbi_dbg(HANDLE_CTX(dev_handle), "%s", dpriv->ugenpath);
+	usbi_dbg(HANDLE_CTX(dev_handle), "ugenpath: %s", idp->idp_ugenpath);
 
-	return (dpriv->ugenpath == NULL);
+	/*
+	 * The only way for libusb to take control of a USB device is if it has
+	 * ugen(4D) device nodes.  Some drivers, like hid(4D), expose ugen
+	 * nodes even though there is a kernel driver attached to the device.
+	 * Such drivers are willing to mediate between in-kernel access and
+	 * access from user programs.  Other devices may be explictly bound to
+	 * ugen, or ugen nodes may be exposed as a fall-back by usb_mid(4D)
+	 * when no other driver ends up matching the device.
+	 *
+	 * In summary: if we were able to find ugen(4D) nodes device
+	 * enumeration, we treat the device as something we can try to open.
+	 * Otherwise, we report that the kernel is holding the device.
+	 */
+	return (idp->idp_ugenpath == NULL);
 }
 
 /*
@@ -153,7 +231,8 @@ static int _errno_to_libusb(int);
 static int illumos_usb_get_status(struct libusb_context *ctx, int fd);
 
 static int
-illumos_bus_number(struct node_args *nargs, di_node_t root_hub, uint8_t *bus)
+illumos_gdl_bus_number(illumos_get_device_list_t *gdl, di_node_t root_hub,
+    illumos_make_session_id_t *msi)
 {
 	/*
 	 * Determine the driver name and instance number for the root hub.
@@ -163,11 +242,13 @@ illumos_bus_number(struct node_args *nargs, di_node_t root_hub, uint8_t *bus)
 	int inum;
 	if ((driver = di_driver_name(root_hub)) == NULL ||
 	    (inum = di_instance(root_hub)) < 0) {
+		usbi_err(gdl->gdl_ctx, "could not get driver/instance");
 		return (EIO);
 	}
 
 	char *instance;
 	if (asprintf(&instance, "%s%d", driver, inum) < 0) {
+		usbi_err(gdl->gdl_ctx, "could not make driver/instance string");
 		return (EIO);
 	}
 
@@ -175,24 +256,22 @@ illumos_bus_number(struct node_args *nargs, di_node_t root_hub, uint8_t *bus)
 	 * Walk through to check if we have assigned this already:
 	 */
 	for (uint_t n = 0; n < MAX_BUSES; n++) {
-		if (nargs->buses[n] == NULL) {
+		if (gdl->gdl_buses[n] == NULL) {
 			/*
 			 * If we reach an unused slot, use that slot for
 			 * this root hub:
 			 */
-			nargs->buses[n] = instance;
-			if (bus != NULL) {
-				*bus = n;
-			}
+			usbi_dbg(gdl->gdl_ctx, "new bus: %s -> bus %u",
+			    instance, n);
+			gdl->gdl_buses[n] = instance;
+			msi->msi_bus_number = n;
 			return (0);
-		} else if (strcmp(nargs->buses[n], instance) == 0) {
+		} else if (strcmp(gdl->gdl_buses[n], instance) == 0) {
 			/*
 			 * This root hub was already assigned a device:
 			 */
 			free(instance);
-			if (bus != NULL) {
-				*bus = n;
-			}
+			msi->msi_bus_number = n;
 			return (0);
 		}
 	}
@@ -201,6 +280,7 @@ illumos_bus_number(struct node_args *nargs, di_node_t root_hub, uint8_t *bus)
 	 * We have run out of bus IDs!
 	 */
 	free(instance);
+	usbi_err(gdl->gdl_ctx, "ran out of bus IDs!");
 	return (EOVERFLOW);
 }
 
@@ -223,20 +303,20 @@ illumos_bus_number(struct node_args *nargs, di_node_t root_hub, uint8_t *bus)
  * zero.
  */
 static int
-illumos_make_session_id(struct node_args *nargs, di_node_t node,
-     uint64_t *sidp, uint8_t *busp, int *is_root_hub)
+illumos_gdl_make_session_id(illumos_get_device_list_t *gdl, di_node_t node,
+     illumos_make_session_id_t *msi)
 {
-	uint64_t sid = 0;
 	uint_t byt = 0;
 
-	if (is_root_hub != NULL) {
-		*is_root_hub = 1;
-	}
+	/*
+	 * Devices are assumed to be root hubs until we discover otherwise:
+	 */
+	msi->msi_is_root_hub = 1;
 
 	while (node != DI_NODE_NIL) {
 		int r;
 		int *unused;
-		int root_hub = 0;
+		int has_root_hub_prop = 0;
 
 		usbi_dbg(NULL, "loop %p", node);
 
@@ -247,12 +327,12 @@ illumos_make_session_id(struct node_args *nargs, di_node_t node,
 		 */
 		if ((r = di_prop_lookup_ints(DDI_DEV_T_ANY, node,
 		    "root-hub", &unused)) == 0) {
-			root_hub = 1;
+			has_root_hub_prop = 1;
 		} else if (r >= 1) {
 			/*
 			 * This should never happen for a boolean property.
 			 */
-			usbi_dbg(NULL, "unexpected root-hub "
+			usbi_err(NULL, "unexpected root-hub "
 			    "lookup return %d", r);
 			return (EIO);
 		} else if (r < 0 && errno != ENXIO) {
@@ -260,21 +340,18 @@ illumos_make_session_id(struct node_args *nargs, di_node_t node,
 			 * Report errors other than a failure to find the
 			 * property.
 			 */
-			usbi_dbg(NULL, "unexpected root-hub "
+			usbi_err(NULL, "unexpected root-hub "
 			    "lookup error %d", errno);
 			return (EIO);
 		}
 
-		if (!root_hub) {
+		if (!has_root_hub_prop) {
 			int *addr;
 
-			if (is_root_hub != NULL) {
-				/*
-				 * If we see any other device, this is not a
-				 * root hub.
-				 */
-				*is_root_hub = 0;
-			}
+			/*
+			 * If we see any other device, this is not a root hub.
+			 */
+			msi->msi_is_root_hub = 0;
 
 			/*
 			 * Get the "assigned-address" value of the current
@@ -287,7 +364,7 @@ illumos_make_session_id(struct node_args *nargs, di_node_t node,
 				/*
 				 * XXX report error
 				 */
-				usbi_dbg(NULL, "unexpected address "
+				usbi_err(NULL, "unexpected address "
 				    "lookup error %d", errno);
 				return (EIO);
 			} else if (r != 1) {
@@ -295,7 +372,7 @@ illumos_make_session_id(struct node_args *nargs, di_node_t node,
 				 * XXX Expected just one integer here, not a
 				 * boolean or a list.
 				 */
-				usbi_dbg(NULL, "unexpected address "
+				usbi_err(NULL, "unexpected address "
 				    "lookup return %d", r);
 				return (EIO);
 			} else if (*addr > UINT8_MAX || *addr < 1) {
@@ -303,7 +380,7 @@ illumos_make_session_id(struct node_args *nargs, di_node_t node,
 				 * We need USB addresses to fit in a byte
 				 * and to be non-zero.
 				 */
-				usbi_dbg(NULL, "unexpected address %d",
+				usbi_err(NULL, "unexpected address %d",
 				    *addr);
 				return (EIO);
 			}
@@ -316,11 +393,11 @@ illumos_make_session_id(struct node_args *nargs, di_node_t node,
 				/*
 				 * We have run out of slots.
 				 */
-				usbi_dbg(NULL, "ran out of slots");
+				usbi_err(NULL, "ran out of slots");
 				return (EIO);
 			}
 			usbi_dbg(NULL, "slot %u = %x", byt, *addr & 0xFF);
-			sid |= (*addr & 0xFF) << (byt++ * 8);
+			msi->msi_session_id |= (*addr & 0xFF) << (byt++ * 8);
 
 			/*
 			 * Walk one node up the device tree.
@@ -333,8 +410,8 @@ illumos_make_session_id(struct node_args *nargs, di_node_t node,
 		 * Assign a bus number to this root hub if we have not done
 		 * that already.
 		 */
-		if ((r = illumos_bus_number(nargs, node, busp)) != 0) {
-			usbi_dbg(NULL, "bus number failure %d", r);
+		if ((r = illumos_gdl_bus_number(gdl, node, msi)) != 0) {
+			usbi_err(NULL, "bus number failure %d", r);
 			return (r);
 		}
 
@@ -349,47 +426,63 @@ illumos_make_session_id(struct node_args *nargs, di_node_t node,
 			/*
 			 * XXX
 			 */
-			usbi_dbg(NULL, "reg lookup failure %d %d", r, errno);
+			usbi_err(NULL, "reg lookup failure %d %d", r, errno);
 			return (EIO);
 		}
-		sid |= (uint64_t)(PCI_REG_FUNC_G(regs[0])) << 48;
-		sid |= (uint64_t)(PCI_REG_DEV_G(regs[0])) << 51;
-		sid |= (uint64_t)(PCI_REG_BUS_G(regs[0])) << 56;
+		msi->msi_session_id |=
+		    ((uint64_t)(PCI_REG_FUNC_G(regs[0])) << 48) |
+		    ((uint64_t)(PCI_REG_DEV_G(regs[0])) << 51) |
+		    ((uint64_t)(PCI_REG_BUS_G(regs[0])) << 56);
 
 		/*
-		 * Once we have found the root hub, the session ID is
-		 * complete.
+		 * Once we have found the root hub, the session ID is complete.
 		 */
-		*sidp = sid;
 		return (0);
 	}
 
 	/*
-	 * If we get down here, it means we have walked out of the tree
-	 * without finding the root hub.
+	 * If we get down here, it means we have walked out of the tree without
+	 * finding the root hub.
 	 */
-	usbi_dbg(NULL, "could not find root hub!");
+	usbi_err(NULL, "could not find root hub!");
 	return (ENOENT);
 }
 
+static void
+illumos_dev_priv_reset(illumos_dev_priv_t *idp)
+{
+	free(idp->idp_raw_cfgdescr);
+	idp->idp_raw_cfgdescr = NULL;
+	idp->idp_cfgvalue = 0;
+
+	free(idp->idp_ugenpath);
+	idp->idp_ugenpath = NULL;
+
+	/*
+	 * This string is allocated with di_devfs_path(3DEVINFO) and thus must
+	 * be freed accordingly:
+	 */
+	di_devfs_path_free(idp->idp_physpath);
+	idp->idp_physpath = NULL;
+}
 
 static int
-illumos_fill_in_dev_info(struct node_args *nargs, di_node_t node,
+illumos_gdl_dev_load(illumos_get_device_list_t *gdl, di_node_t node,
     struct libusb_device *dev)
 {
 	int proplen;
-	int *i, n, *addr, *port_prop;
-	char *phypath;
+	int n, *addr, *port_prop;
 	uint8_t *rdata;
-	illumos_dev_priv_t *dpriv = usbi_get_device_priv(dev);
-	char match_str[PATH_MAX];
+	illumos_dev_priv_t *idp = usbi_get_device_priv(dev);
 	di_node_t parent;
+	int r = LIBUSB_ERROR_IO;
 
 	/* Device descriptors */
 	proplen = di_prop_lookup_bytes(DDI_DEV_T_ANY, node,
 	    "usb-dev-descriptor", &rdata);
 	if (proplen <= 0) {
-		return (LIBUSB_ERROR_IO);
+		usbi_err(DEVICE_CTX(dev), "could not get device descriptor");
+		goto bail;
 	}
 	bcopy(rdata, &dev->device_descriptor, LIBUSB_DT_DEVICE_SIZE);
 
@@ -397,19 +490,19 @@ illumos_fill_in_dev_info(struct node_args *nargs, di_node_t node,
 	proplen = di_prop_lookup_bytes(DDI_DEV_T_ANY, node,
 	    "usb-raw-cfg-descriptors", &rdata);
 	if (proplen <= 0) {
-		usbi_dbg(DEVICE_CTX(dev), "can't find raw config descriptors");
-
-		return (LIBUSB_ERROR_IO);
+		usbi_err(DEVICE_CTX(dev), "could not get raw config");
+		goto bail;
 	}
-	dpriv->raw_cfgdescr = calloc(1, proplen);
-	if (dpriv->raw_cfgdescr == NULL) {
-		return (LIBUSB_ERROR_NO_MEM);
-	} else {
-		bcopy(rdata, dpriv->raw_cfgdescr, proplen);
-		dpriv->cfgvalue = ((struct libusb_config_descriptor *)
-		    rdata)->bConfigurationValue;
+	free(idp->idp_raw_cfgdescr);
+	if ((idp->idp_raw_cfgdescr = calloc(1, proplen)) == NULL) {
+		r = LIBUSB_ERROR_NO_MEM;
+		goto bail;
 	}
 
+	bcopy(rdata, idp->idp_raw_cfgdescr, proplen);
+	idp->idp_cfgvalue = ((struct libusb_config_descriptor *)
+	    rdata)->bConfigurationValue;
+
 	/*
 	 * The "reg" property contains the port number that this device
 	 * is connected to, which is of course only unique within the hub
@@ -417,7 +510,8 @@ illumos_fill_in_dev_info(struct node_args *nargs, di_node_t node,
 	 */
 	n = di_prop_lookup_ints(DDI_DEV_T_ANY, node, "reg", &port_prop);
 	if (n != 1 || *port_prop <= 0) {
-		return (LIBUSB_ERROR_IO);
+		usbi_err(DEVICE_CTX(dev), "could not get reg property");
+		goto bail;
 	}
 	dev->port_number = *port_prop;
 
@@ -430,294 +524,370 @@ illumos_fill_in_dev_info(struct node_args *nargs, di_node_t node,
 	 * used by software like hidapi to uniquely identify a device.
 	 */
 	if ((parent = di_parent_node(node)) == DI_NODE_NIL) {
-		usbi_dbg(DEVICE_CTX(dev), "could not get parent node");
-		return (LIBUSB_ERROR_IO);
+		usbi_err(DEVICE_CTX(dev), "could not get parent node");
+		goto bail;
 	} else {
-		uint64_t psid;
-		int is_root_hub;
-		if (illumos_make_session_id(nargs, parent, &psid, NULL,
-		    &is_root_hub) != 0) {
-			usbi_dbg(DEVICE_CTX(dev), "could not get "
+		illumos_make_session_id_t msi = {};
+		if (illumos_gdl_make_session_id(gdl, parent, &msi) != 0) {
+			usbi_err(DEVICE_CTX(dev), "could not get "
 			    "session ID for parent node");
-			return (LIBUSB_ERROR_IO);
+			goto bail;
 		}
 
-		if (is_root_hub) {
+		if (msi.msi_is_root_hub) {
 			usbi_dbg(DEVICE_CTX(dev), "parent device %llx "
 			    "for session ID %llx is a root hub",
-			    (unsigned long long)psid,
+			    (unsigned long long)msi.msi_session_id,
 			    (unsigned long long)dev->session_data);
 			dev->parent_dev = NULL;
 		} else if ((dev->parent_dev = usbi_get_device_by_session_id(
-		    nargs->ctx, psid)) == NULL) {
-			usbi_dbg(DEVICE_CTX(dev), "could not locate "
+		    gdl->gdl_ctx, msi.msi_session_id)) == NULL) {
+			usbi_err(DEVICE_CTX(dev), "could not locate "
 			    "parent device %llx for session ID %llx",
-			    (unsigned long long)psid,
+			    (unsigned long long)msi.msi_session_id,
 			    (unsigned long long)dev->session_data);
-			return (LIBUSB_ERROR_IO);
+			goto bail;
 		}
 	}
 
-	/* device physical path */
-	phypath = di_devfs_path(node);
-	if (phypath) {
-		dpriv->phypath = strdup(phypath);
-		snprintf(match_str, sizeof(match_str), "^usb/%x.%x",
-		    dev->device_descriptor.idVendor,
-		    dev->device_descriptor.idProduct);
-		usbi_dbg(DEVICE_CTX(dev), "match is %s", match_str);
-		illumos_physpath_to_devlink(dpriv->phypath, match_str,
-		    &dpriv->ugenpath);
-		di_devfs_path_free(phypath);
-	} else {
-		free(dpriv->raw_cfgdescr);
+	/*
+	 * Get the /devices path for this device, and use it to locate the
+	 * ugen(4D) /dev path:
+	 */
+	di_devfs_path_free(idp->idp_physpath);
+	if ((idp->idp_physpath = di_devfs_path(node)) == NULL) {
+		if (errno == EAGAIN) {
+			r = LIBUSB_ERROR_NO_MEM;
+		}
+		usbi_err(DEVICE_CTX(dev), "could not get /devices path: "
+		    "errno %d", errno);
+		goto bail;
+	}
 
-		return (LIBUSB_ERROR_IO);
+	if (illumos_gdl_find_ugenpath(gdl, dev) != 0) {
+		/*
+		 * Not every device will be accessible via ugen(4D).  We still
+		 * need to enumerate devices even if they cannot currently be
+		 * controlled, so this is not a fatal error.
+		 */
+		usbi_warn(DEVICE_CTX(dev), "could not get ugen path");
 	}
 
 	/* address */
 	n = di_prop_lookup_ints(DDI_DEV_T_ANY, node, "assigned-address",
 	    &addr);
 	if (n != 1 || *addr == 0) {
-		usbi_dbg(DEVICE_CTX(dev), "can't get address");
+		usbi_err(DEVICE_CTX(dev), "can't get address");
 	} else {
 		dev->device_address = *addr;
 	}
 
-	/* speed */
-	if (di_prop_lookup_ints(DDI_DEV_T_ANY, node, "low-speed", &i) >= 0) {
-		dev->speed = LIBUSB_SPEED_LOW;
-	} else if (di_prop_lookup_ints(DDI_DEV_T_ANY, node, "high-speed",
-	    &i) >= 0) {
-		dev->speed = LIBUSB_SPEED_HIGH;
-	} else if (di_prop_lookup_ints(DDI_DEV_T_ANY, node, "full-speed",
-	    &i) >= 0) {
-		dev->speed = LIBUSB_SPEED_FULL;
-	} else if (di_prop_lookup_ints(DDI_DEV_T_ANY, node, "super-speed",
-	    &i) >= 0) {
-		dev->speed = LIBUSB_SPEED_SUPER;
+	/*
+	 * Device speed is reported as a boolean node property; e.g.,
+	 * "high-speed".  Find the highest reported speed property for this
+	 * device:
+	 */
+	dev->speed = LIBUSB_SPEED_UNKNOWN;
+	for (uint_t i = 0; i < ARRAY_SIZE(illumos_speed_props); i++) {
+		int *unused;
+
+		if (di_prop_lookup_ints(DDI_DEV_T_ANY, node,
+		    illumos_speed_props[i].name, &unused) >= 0) {
+			dev->speed = illumos_speed_props[i].speed;
+			break;
+		}
 	}
 
 	usbi_dbg(DEVICE_CTX(dev),
 	    "vid=%x pid=%x, path=%s, bus=%u, port_number=%d, speed=%d",
 	    dev->device_descriptor.idVendor,
 	    dev->device_descriptor.idProduct,
-	    dpriv->phypath, dev->bus_number, dev->port_number, dev->speed);
+	    idp->idp_physpath, dev->bus_number, dev->port_number, dev->speed);
 
 	return (LIBUSB_SUCCESS);
+
+bail:
+	illumos_dev_priv_reset(idp);
+	return (r);
 }
 
 static int
-illumos_add_devices(di_devlink_t link, void *arg)
+illumos_gdl_dev_append(illumos_get_device_list_t *gdl,
+    struct libusb_device *dev)
 {
-	struct devlink_cbarg *largs = (struct devlink_cbarg *)arg;
-	struct node_args *nargs = largs->nargs;
-	struct libusb_device *dev;
-	illumos_dev_priv_t *devpriv;
-	int r;
+	struct discovered_devs *dd = *gdl->gdl_discdevs;
+	int r = 0;
 
-	UNUSED(link);
-
-	for (di_node_t node = di_child_node(largs->myself);
-	    node != DI_NODE_NIL; node = di_sibling_node(node)) {
-		uint64_t session_id = 0;
-		uint8_t bus_number = 0;
-		int root_hub = 0;
-		if ((r = illumos_make_session_id(nargs, node, &session_id,
-		    &bus_number, &root_hub)) != 0) {
-			usbi_dbg(NULL, "could not generate session ID (%d)",
-			    r);
-			return (DI_WALK_TERMINATE);
+	/*
+	 * This routine will automatically realloc(3C) the device list if
+	 * required, but unlike realloc() it will automatically free the
+	 * original list on failure.  Either way, we always want to replace our
+	 * pointer with the returned pointer.
+	 */
+	if ((dd = discovered_devs_append(dd, dev)) == NULL) {
+		usbi_err(NULL, "could not append device");
+		r = -1;
+	}
+
+	*gdl->gdl_discdevs = dd;
+	return (r);
+}
+
+static int
+illumos_gdl_scan_hub(illumos_get_device_list_t *gdl, di_node_t hub_node)
+{
+	struct libusb_context *ctx = gdl->gdl_ctx;
+	char *hpath = di_devfs_path(hub_node);
+	usbi_dbg(gdl->gdl_ctx, "scanning under hub: %s", hpath);
+	di_devfs_path_free(hpath);
+
+	for (di_node_t node = di_child_node(hub_node); node != DI_NODE_NIL;
+	    node = di_sibling_node(node)) {
+		int r;
+		illumos_make_session_id_t msi = {};
+		if ((r = illumos_gdl_make_session_id(gdl, node, &msi) != 0)) {
+			usbi_err(ctx, "could not generate session ID (%d)", r);
+			continue;
 		}
 
 		char *path = di_devfs_path(node);
 		if (path == NULL) {
-			usbi_dbg(NULL, "di_devfs_path() failure!");
-			return (DI_WALK_TERMINATE);
+			usbi_err(ctx, "di_devfs_path() failure!");
+			continue;
 		}
 
-		usbi_dbg(NULL,
+		usbi_dbg(ctx,
 		    "bus number = %u, session ID = 0x%llx, path = %s",
-		    (uint_t)bus_number, (unsigned long long)session_id,
+		    (uint_t)msi.msi_bus_number,
+		    (unsigned long long)msi.msi_session_id,
 		    path);
 
 		di_devfs_path_free(path);
 
-		if (root_hub) {
-			usbi_dbg(NULL, "skipping root hub (%llx)",
-			    (unsigned long long)session_id);
+		if (msi.msi_is_root_hub) {
+			usbi_dbg(ctx, "skipping root hub (%llx)",
+			    (unsigned long long)msi.msi_session_id);
 			continue;
 		}
 
-		dev = usbi_get_device_by_session_id(nargs->ctx, session_id);
+		/*
+		 * Whether we locate the device by its session ID, or allocate
+		 * a new device here, we need to unref the device afterwards.
+		 */
+		struct libusb_device *dev =
+		    usbi_get_device_by_session_id(gdl->gdl_ctx,
+		    msi.msi_session_id);
 		if (dev == NULL) {
-			dev = usbi_alloc_device(nargs->ctx, session_id);
-			if (dev == NULL) {
-				usbi_dbg(NULL, "can't alloc device");
+			if ((dev = usbi_alloc_device(gdl->gdl_ctx,
+			    msi.msi_session_id)) == NULL) {
+				usbi_err(ctx, "can't alloc device");
 				continue;
 			}
-			devpriv = usbi_get_device_priv(dev);
-			dev->bus_number = bus_number;
 
-			if (illumos_fill_in_dev_info(nargs, node, dev) !=
-			    LIBUSB_SUCCESS) {
-				libusb_unref_device(dev);
-				usbi_dbg(NULL, "get information fail");
-				continue;
-			}
-			if (usbi_sanitize_device(dev) < 0) {
-				libusb_unref_device(dev);
-				usbi_dbg(NULL, "sanatize failed: ");
-				return (DI_WALK_TERMINATE);
-			}
+			usbi_dbg(DEVICE_CTX(dev), "device allocated");
 		} else {
-			devpriv = usbi_get_device_priv(dev);
-			usbi_dbg(NULL, "Dev %s exists", devpriv->ugenpath);
+			usbi_warn(DEVICE_CTX(dev), "device exists already");
 		}
 
-		if (discovered_devs_append(*(nargs->discdevs), dev) == NULL) {
-			usbi_dbg(NULL, "cannot append device");
+		dev->bus_number = msi.msi_bus_number;
+
+		if (illumos_gdl_dev_load(gdl, node, dev) !=
+		    LIBUSB_SUCCESS) {
+			usbi_err(ctx, "device info load (id 0x%" PRIx64 ")",
+			    msi.msi_session_id);
+			goto unref;
 		}
 
-		/*
-		 * we alloc and hence ref this dev. We don't need to ref it
-		 * hereafter. Front end or app should take care of their ref.
-		 */
-		libusb_unref_device(dev);
+		if (usbi_sanitize_device(dev) < 0) {
+			usbi_err(ctx, "sanatize failed");
+			goto unref;
+		}
 
-		usbi_dbg(NULL, "Device %s %s id=0x%" PRIx64
-		    ", devcount:%" PRIuPTR,
-		    devpriv->ugenpath, devpriv->phypath,
-		    (uint64_t)session_id, (*nargs->discdevs)->len);
+		if (illumos_gdl_dev_append(gdl, dev) != 0) {
+			goto unref;
+		}
+
+		illumos_dev_priv_t *idp = usbi_get_device_priv(dev);
+		usbi_dbg(ctx, "Device %s %s id=0x%" PRIx64 ", "
+		    "devcount:%" PRIuPTR,
+		    idp->idp_ugenpath, idp->idp_physpath,
+		    msi.msi_session_id, (*gdl->gdl_discdevs)->len);
+
+unref:
+		libusb_unref_device(dev);
 	}
 
 	return (DI_WALK_CONTINUE);
 }
 
 static int
-illumos_walk_minor_node_link(di_node_t node, void *args)
+illumos_gdl_find_hub_walk(di_devlink_t link, void *arg)
+{
+	illumos_gdl_find_hubs_t *dlfh = arg;
+
+	usbi_dbg(dlfh->dlfh_ctx, "found hub link: %s -> %s",
+	    di_devlink_path(link) == NULL ? "?" : di_devlink_path(link),
+	    di_devlink_content(link) == NULL ? "?" : di_devlink_content(link));
+
+	dlfh->dlfh_is_hub = 1;
+
+	return (DI_WALK_TERMINATE);
+}
+
+static int
+illumos_gdl_find_hubs(di_node_t node, void *arg)
 {
-	di_minor_t minor = DI_MINOR_NIL;
-	char *minor_path;
-	struct devlink_cbarg arg;
-	struct node_args *nargs = (struct node_args *)args;
-	di_devlink_handle_t devlink_hdl = nargs->dlink_hdl;
-
-	/* walk each minor to find usb devices */
-	while ((minor = di_minor_next(node, minor)) != DI_MINOR_NIL) {
-		minor_path = di_devfs_minor_path(minor);
-		arg.nargs = args;
-		arg.myself = node;
-		arg.minor = minor;
-		(void) di_devlink_walk(devlink_hdl,
-		    "^usb/hub[0-9]+", minor_path,
-		    DI_PRIMARY_LINK, (void *)&arg, illumos_add_devices);
+	illumos_get_device_list_t *gdl = arg;
+
+	/*
+	 * Walk the minor nodes of this device to see if it is a USB hub:
+	 */
+	for (di_minor_t minor = di_minor_next(node, DI_MINOR_NIL);
+	    minor != DI_MINOR_NIL; minor = di_minor_next(node, minor)) {
+		char *minor_path = di_devfs_minor_path(minor);
+
+		/*usbi_dbg(gdl->gdl_ctx, "finding hubs: %s", minor_path);*/
+
+		illumos_gdl_find_hubs_t dlfh = {
+			.dlfh_ctx = gdl->gdl_ctx,
+		};
+		int r = di_devlink_walk(gdl->gdl_devlink, "^usb/hub[0-9]+",
+		    minor_path, DI_PRIMARY_LINK, &dlfh,
+		    illumos_gdl_find_hub_walk);
+		if (r != 0) {
+			usbi_err(gdl->gdl_ctx, "di_devlink_walk() failed: "
+			    "errno %d (%s)", errno, strerror(errno));
+		}
+
+		if (dlfh.dlfh_is_hub) {
+			illumos_gdl_scan_hub(gdl, node);
+		}
+
 		di_devfs_path_free(minor_path);
 	}
 
-	/* switch to a different node */
-	nargs->last_ugenpath = NULL;
-
 	return (DI_WALK_CONTINUE);
 }
 
+/*
+ * Locate USB devices by locating all USB hub device nodes (linked as
+ * /dev/usb/hub[0-9]+) and then enumerating all child device nodes under the
+ * hub devices.
+ */
 int
-illumos_get_device_list(struct libusb_context * ctx,
-	struct discovered_devs **discdevs)
+illumos_get_device_list(struct libusb_context *ctx,
+    struct discovered_devs **discdevs)
 {
-	di_node_t root_node;
-	struct node_args args;
-	di_devlink_handle_t devlink_hdl;
-
-	args.ctx = ctx;
-	args.discdevs = discdevs;
-	args.last_ugenpath = NULL;
-	bzero(args.buses, sizeof (args.buses));
+	di_node_t root_node = DI_NODE_NIL;
+	di_devlink_handle_t dlh = NULL;
+	int r = LIBUSB_ERROR_IO;
+
 	if ((root_node = di_init("/", DINFOCPYALL)) == DI_NODE_NIL) {
-		usbi_dbg(ctx, "di_int() failed: errno %d (%s)", errno,
+		usbi_err(ctx, "di_init() failed: errno %d (%s)", errno,
 		    strerror(errno));
-		return (LIBUSB_ERROR_IO);
+		goto out;
 	}
 
-	if ((devlink_hdl = di_devlink_init(NULL, 0)) == NULL) {
-		di_fini(root_node);
-		usbi_dbg(ctx, "di_devlink_init() failed: errno %d (%s)", errno,
+	if ((dlh = di_devlink_init(NULL, 0)) == NULL) {
+		usbi_err(ctx, "di_devlink_init() failed: errno %d (%s)", errno,
 		    strerror(errno));
-		return (LIBUSB_ERROR_IO);
+		goto out;
 	}
-	args.dlink_hdl = devlink_hdl;
 
-	/* walk each node to find USB devices */
-	if (di_walk_node(root_node, DI_WALK_SIBFIRST, &args,
-	    illumos_walk_minor_node_link) == -1) {
-		usbi_dbg(ctx, "di_walk_node() failed: errno %d (%s)", errno,
+	/*
+	 * Walk all device nodes to locate USB hubs.
+	 */
+	illumos_get_device_list_t gdl = {
+		.gdl_ctx = ctx,
+		.gdl_discdevs = discdevs,
+		.gdl_devlink = dlh,
+	};
+	if (di_walk_node(root_node, DI_WALK_SIBFIRST, &gdl,
+	    illumos_gdl_find_hubs) != 0) {
+		usbi_err(ctx, "di_walk_node() failed: errno %d (%s)", errno,
 		    strerror(errno));
-		di_fini(root_node);
-		return (LIBUSB_ERROR_IO);
+		goto out;
 	}
 
-	di_fini(root_node);
-	di_devlink_fini(&devlink_hdl);
-
 	usbi_dbg(ctx, "%zu devices", (*discdevs)->len);
+	r = (*discdevs)->len;
+
+out:
+	if (dlh != NULL) {
+		di_devlink_fini(&dlh);
+	}
+	if (root_node != DI_NODE_NIL) {
+		di_fini(root_node);
+	}
 
-	return ((*discdevs)->len);
+	return (r);
 }
 
 static int
-illumos_usb_open_ep0(illumos_dev_handle_priv_t *hpriv,
-    illumos_dev_priv_t *dpriv)
+illumos_usb_open_ep0(struct libusb_context *ctx, illumos_dev_handle_priv_t *ihp,
+    illumos_dev_priv_t *idp)
 {
 	char filename[PATH_MAX + 1];
+	int e;
+
+	/*
+	 * If we get here, the device must be one that we believe we can open;
+	 * viz., we must have found a ugen(4D) device node for it:
+	 */
+	assert(idp->idp_ugenpath != NULL);
 
-	if (hpriv->eps[0].datafd > 0) {
+	if (ihp->ihp_eps[0].datafd >= 0) {
+		usbi_warn(ctx, "ep0 already open!");
+		assert(ihp->ihp_eps[0].statfd > 0);
 		return (LIBUSB_SUCCESS);
 	}
-	snprintf(filename, PATH_MAX, "%s/cntrl0", dpriv->ugenpath);
 
-	usbi_dbg(NULL, "opening %s", filename);
-	hpriv->eps[0].datafd = open(filename, O_RDWR);
-	if (hpriv->eps[0].datafd < 0) {
-		return (_errno_to_libusb(errno));
+	(void) snprintf(filename, PATH_MAX, "%s/cntrl0", idp->idp_ugenpath);
+	usbi_dbg(ctx, "opening default endpoint: %s", filename);
+	if ((ihp->ihp_eps[0].datafd = open(filename, O_RDWR)) < 0) {
+		e = errno;
+		usbi_err(ctx, "failed to open default endpoint: %s: errno %d",
+		    filename, e);
+		goto fail;
+
 	}
 
-	snprintf(filename, PATH_MAX, "%s/cntrl0stat", dpriv->ugenpath);
-	hpriv->eps[0].statfd = open(filename, O_RDONLY);
-	if (hpriv->eps[0].statfd < 0) {
-		close(hpriv->eps[0].datafd);
-		hpriv->eps[0].datafd = -1;
-		return (_errno_to_libusb(errno));
+	(void) snprintf(filename, PATH_MAX, "%s/cntrl0stat", idp->idp_ugenpath);
+	if ((ihp->ihp_eps[0].statfd = open(filename, O_RDONLY)) < 0) {
+		e = errno;
+		usbi_err(ctx, "failed to open default endpoint status: %s: "
+		    "errno %d", filename, e);
+		goto fail;
 	}
 
 	return (LIBUSB_SUCCESS);
+
+fail:
+	illumos_ensure_closed(ctx, &ihp->ihp_eps[0].datafd);
+	illumos_ensure_closed(ctx, &ihp->ihp_eps[0].statfd);
+	return (_errno_to_libusb(e));
 }
 
 static void
-illumos_usb_close_all_eps(illumos_dev_handle_priv_t *hdev)
+illumos_usb_close_all_eps(struct libusb_context *ctx,
+    illumos_dev_handle_priv_t *ihp)
 {
-	int i;
-
-	/* not close ep0 */
-	for (i = 1; i < USB_MAXENDPOINTS; i++) {
-		if (hdev->eps[i].datafd != -1) {
-			(void) close(hdev->eps[i].datafd);
-			hdev->eps[i].datafd = -1;
-		}
-		if (hdev->eps[i].statfd != -1) {
-			(void) close(hdev->eps[i].statfd);
-			hdev->eps[i].statfd = -1;
-		}
+	/*
+	 * Skip the default endpoint (endpoint 0), closing all the others:
+	 */
+	for (uint_t i = 1; i < USB_MAXENDPOINTS; i++) {
+		illumos_ensure_closed(ctx, &ihp->ihp_eps[i].datafd);
+		illumos_ensure_closed(ctx, &ihp->ihp_eps[i].statfd);
 	}
 }
 
 static void
-illumos_usb_close_ep0(illumos_dev_handle_priv_t *hdev)
+illumos_usb_close_ep0(struct libusb_context *ctx,
+    illumos_dev_handle_priv_t *ihp)
 {
-	if (hdev->eps[0].datafd >= 0) {
-		close(hdev->eps[0].datafd);
-		close(hdev->eps[0].statfd);
-		hdev->eps[0].datafd = -1;
-		hdev->eps[0].statfd = -1;
+	if (ihp->ihp_eps[0].datafd >= 0) {
+		illumos_ensure_closed(ctx, &ihp->ihp_eps[0].datafd);
+		illumos_ensure_closed(ctx, &ihp->ihp_eps[0].statfd);
 	}
 }
 
@@ -738,7 +908,7 @@ illumos_find_interface(struct libusb_device_handle *hdev,
 
 	r = libusb_get_active_config_descriptor(hdev->dev, &config);
 	if (r < 0) {
-		usbi_dbg(HANDLE_CTX(hdev), "could not get active desc");
+		usbi_err(HANDLE_CTX(hdev), "could not get active desc");
 		return (LIBUSB_ERROR_INVALID_PARAM);
 	}
 
@@ -789,14 +959,14 @@ illumos_check_device_and_status_open(struct libusb_device_handle *hdl,
 	int fd, fdstat, mode, e;
 	uint8_t ifc = 0;
 	uint8_t ep_index;
-	illumos_dev_handle_priv_t *hpriv;
+	illumos_dev_handle_priv_t *ihp;
 
 	usbi_dbg(HANDLE_CTX(hdl), "open ep 0x%02x", ep_addr);
-	hpriv = usbi_get_device_handle_priv(hdl);
+	ihp = usbi_get_device_handle_priv(hdl);
 	ep_index = illumos_usb_ep_index(ep_addr);
 	/* ep already opened */
-	if ((hpriv->eps[ep_index].datafd > 0) &&
-	    (hpriv->eps[ep_index].statfd > 0)) {
+	if ((ihp->ihp_eps[ep_index].datafd > 0) &&
+	    (ihp->ihp_eps[ep_index].statfd > 0)) {
 		usbi_dbg(HANDLE_CTX(hdl),
 		    "ep 0x%02x already opened, return success", ep_addr);
 
@@ -804,34 +974,34 @@ illumos_check_device_and_status_open(struct libusb_device_handle *hdl,
 	}
 
 	if (illumos_find_interface(hdl, ep_addr, &ifc) < 0) {
-		usbi_dbg(HANDLE_CTX(hdl),
+		usbi_err(HANDLE_CTX(hdl),
 		    "can't find interface for endpoint 0x%02x", ep_addr);
 		return (EACCES);
 	}
 
 	/* create filename */
-	if (hpriv->config_index > 0) {
+	if (ihp->ihp_config_index > 0) {
 		(void) snprintf(cfg_num, sizeof(cfg_num), "cfg%d",
-		    hpriv->config_index + 1);
+		    ihp->ihp_config_index + 1);
 	} else {
 		bzero(cfg_num, sizeof(cfg_num));
 	}
 
-	if (hpriv->altsetting[ifc] > 0) {
+	if (ihp->ihp_altsetting[ifc] > 0) {
 		(void) snprintf(alt_num, sizeof(alt_num), ".%d",
-		    hpriv->altsetting[ifc]);
+		    ihp->ihp_altsetting[ifc]);
 	} else {
 		bzero(alt_num, sizeof(alt_num));
 	}
 
 	if ((e = snprintf(filename, sizeof (filename), "%s/%sif%d%s%s%d",
-	    hpriv->dpriv->ugenpath, cfg_num, ifc, alt_num,
+	    ihp->ihp_idp->idp_ugenpath, cfg_num, ifc, alt_num,
 	    (ep_addr & LIBUSB_ENDPOINT_DIR_MASK) ? "in" :
 	    "out", (ep_addr & LIBUSB_ENDPOINT_ADDRESS_MASK))) < 0 ||
 	    e >= (int)sizeof (filename) ||
 	    (e = snprintf(statfilename, sizeof (statfilename), "%sstat",
 	    filename)) < 0 || e >= (int)sizeof (statfilename)) {
-		usbi_dbg(HANDLE_CTX(hdl),
+		usbi_err(HANDLE_CTX(hdl),
 		    "path buffer overflow for endpoint 0x%02x", ep_addr);
 		return (EINVAL);
 	}
@@ -855,13 +1025,13 @@ illumos_check_device_and_status_open(struct libusb_device_handle *hdl,
 		mode = O_WRONLY;
 	}
 	/* Open the xfer endpoint first */
-	if ((fd = open(filename, mode)) == -1) {
-		usbi_dbg(HANDLE_CTX(hdl), "can't open %s: errno %d (%s)",
+	if ((fd = open(filename, mode)) < 0) {
+		usbi_err(HANDLE_CTX(hdl), "can't open %s: errno %d (%s)",
 		    filename, errno, strerror(errno));
 		return (errno);
 	}
 	/* And immediately close the xfer endpoint */
-	(void) close(fd);
+	illumos_ensure_closed(HANDLE_CTX(hdl), &fd);
 
 	/*
 	 * Open the status endpoint.
@@ -875,8 +1045,8 @@ illumos_check_device_and_status_open(struct libusb_device_handle *hdl,
 		ssize_t count;
 
 		/* Open the status endpoint with RDWR */
-		if ((fdstat = open(statfilename, O_RDWR)) == -1) {
-			usbi_dbg(HANDLE_CTX(hdl),
+		if ((fdstat = open(statfilename, O_RDWR)) < 0) {
+			usbi_err(HANDLE_CTX(hdl),
 			    "can't open %s RDWR: errno %d (%s)",
 			    statfilename, errno, strerror(errno));
 			return (errno);
@@ -884,16 +1054,17 @@ illumos_check_device_and_status_open(struct libusb_device_handle *hdl,
 			count = write(fdstat, &control, sizeof(control));
 			if (count != 1) {
 				/* this should have worked */
-				usbi_dbg(HANDLE_CTX(hdl),
+				e = errno;
+				usbi_err(HANDLE_CTX(hdl),
 				    "can't write to %s: errno %d (%s)",
-				    statfilename, errno, strerror(errno));
-				(void) close(fdstat);
-				return (errno);
+				    statfilename, e, strerror(e));
+				illumos_ensure_closed(HANDLE_CTX(hdl), &fdstat);
+				return (e);
 			}
 		}
 	} else {
-		if ((fdstat = open(statfilename, O_RDONLY)) == -1) {
-			usbi_dbg(HANDLE_CTX(hdl),
+		if ((fdstat = open(statfilename, O_RDONLY)) < 0) {
+			usbi_err(HANDLE_CTX(hdl),
 			    "can't open %s: errno %d (%s)", statfilename, errno,
 			    strerror(errno));
 			return (errno);
@@ -901,15 +1072,16 @@ illumos_check_device_and_status_open(struct libusb_device_handle *hdl,
 	}
 
 	/* Re-open the xfer endpoint */
-	if ((fd = open(filename, mode)) == -1) {
-		usbi_dbg(HANDLE_CTX(hdl), "can't open %s: errno %d (%s)",
-		    filename, errno, strerror(errno));
-		(void) close(fdstat);
-		return (errno);
+	if ((fd = open(filename, mode)) < 0) {
+		e = errno;
+		usbi_err(HANDLE_CTX(hdl), "can't open %s: errno %d (%s)",
+		    filename, e, strerror(errno));
+		illumos_ensure_closed(HANDLE_CTX(hdl), &fdstat);
+		return (e);
 	}
 
-	hpriv->eps[ep_index].datafd = fd;
-	hpriv->eps[ep_index].statfd = fdstat;
+	ihp->ihp_eps[ep_index].datafd = fd;
+	ihp->ihp_eps[ep_index].statfd = fdstat;
 	usbi_dbg(HANDLE_CTX(hdl), "ep=0x%02x datafd=%d, statfd=%d", ep_addr,
 	    fd, fdstat);
 	return (0);
@@ -918,28 +1090,39 @@ illumos_check_device_and_status_open(struct libusb_device_handle *hdl,
 int
 illumos_open(struct libusb_device_handle *handle)
 {
-	illumos_dev_handle_priv_t *hpriv;
-	illumos_dev_priv_t *dpriv;
+	struct libusb_context *ctx = HANDLE_CTX(handle);
+	illumos_dev_handle_priv_t *ihp = usbi_get_device_handle_priv(handle);
+	illumos_dev_priv_t *idp = usbi_get_device_priv(handle->dev);
 	int i;
 	int ret;
 
-	hpriv = usbi_get_device_handle_priv(handle);
-	dpriv = usbi_get_device_priv(handle->dev);
-	hpriv->dpriv = dpriv;
+	ihp->ihp_idp = idp;
 
-	/* set all file descriptors to "closed" */
+	/*
+	 * Reset the file descriptor state on our device handle object.  We
+	 * assert that the memory was zeroed prior to being handed to us.
+	 */
 	for (i = 0; i < USB_MAXENDPOINTS; i++) {
-		hpriv->eps[i].datafd = -1;
-		hpriv->eps[i].statfd = -1;
+		assert(ihp->ihp_eps[i].datafd == 0);
+		ihp->ihp_eps[i].datafd = -1;
+		assert(ihp->ihp_eps[i].statfd == 0);
+		ihp->ihp_eps[i].statfd = -1;
 	}
 
 	if (illumos_kernel_driver_active(handle, 0)) {
-		/* pretend we can open the device */
+		/*
+		 * We don't have a ugen(4D) path for the device, so just
+		 * pretend that we can open it.  This allows a program to open
+		 * any enumerated device.  Any subsequent operation that
+		 * requires ugen access will fail, but the consumer won't get
+		 * confused about the inability to open the otherwise
+		 * enumerated device.
+		 */
 		return (LIBUSB_SUCCESS);
 	}
 
-	if ((ret = illumos_usb_open_ep0(hpriv, dpriv)) != LIBUSB_SUCCESS) {
-		usbi_dbg(HANDLE_CTX(handle), "fail: %d", ret);
+	if ((ret = illumos_usb_open_ep0(ctx, ihp, idp)) != LIBUSB_SUCCESS) {
+		usbi_err(ctx, "open failed: %d", ret);
 		return (ret);
 	}
 
@@ -949,21 +1132,20 @@ illumos_open(struct libusb_device_handle *handle)
 void
 illumos_close(struct libusb_device_handle *handle)
 {
-	illumos_dev_handle_priv_t *hpriv;
-
-	usbi_dbg(HANDLE_CTX(handle), " ");
+	struct libusb_context *ctx = HANDLE_CTX(handle);
+	illumos_dev_handle_priv_t *ihp = usbi_get_device_handle_priv(handle);
 
-	hpriv = usbi_get_device_handle_priv(handle);
+	usbi_dbg(ctx, "closing");
 
-	illumos_usb_close_all_eps(hpriv);
-	illumos_usb_close_ep0(hpriv);
+	illumos_usb_close_all_eps(ctx, ihp);
+	illumos_usb_close_ep0(ctx, ihp);
 }
 
 int
 illumos_get_active_config_descriptor(struct libusb_device *dev,
     void *buf, size_t len)
 {
-	illumos_dev_priv_t *dpriv = usbi_get_device_priv(dev);
+	illumos_dev_priv_t *idp = usbi_get_device_priv(dev);
 	struct libusb_config_descriptor *cfg;
 	int proplen;
 	di_node_t node;
@@ -973,31 +1155,31 @@ illumos_get_active_config_descriptor(struct libusb_device *dev,
 	 * Keep raw configuration descriptors updated, in case config
 	 * has ever been changed through setCfg.
 	 */
-	if ((node = di_init(dpriv->phypath, DINFOCPYALL)) == DI_NODE_NIL) {
-		usbi_dbg(DEVICE_CTX(dev), "di_int() failed: errno %d (%s)",
+	if ((node = di_init(idp->idp_physpath, DINFOCPYALL)) == DI_NODE_NIL) {
+		usbi_err(DEVICE_CTX(dev), "di_int() failed: errno %d (%s)",
 		    errno, strerror(errno));
 		return (LIBUSB_ERROR_IO);
 	}
 	proplen = di_prop_lookup_bytes(DDI_DEV_T_ANY, node,
 	    "usb-raw-cfg-descriptors", &rdata);
 	if (proplen <= 0) {
-		usbi_dbg(DEVICE_CTX(dev), "can't find raw config descriptors");
+		usbi_err(DEVICE_CTX(dev), "can't find raw config descriptors");
 		return (LIBUSB_ERROR_IO);
 	}
-	dpriv->raw_cfgdescr = realloc(dpriv->raw_cfgdescr, proplen);
-	if (dpriv->raw_cfgdescr == NULL) {
+	idp->idp_raw_cfgdescr = realloc(idp->idp_raw_cfgdescr, proplen);
+	if (idp->idp_raw_cfgdescr == NULL) {
 		return (LIBUSB_ERROR_NO_MEM);
 	} else {
-		bcopy(rdata, dpriv->raw_cfgdescr, proplen);
-		dpriv->cfgvalue = ((struct libusb_config_descriptor *)
+		bcopy(rdata, idp->idp_raw_cfgdescr, proplen);
+		idp->idp_cfgvalue = ((struct libusb_config_descriptor *)
 		    rdata)->bConfigurationValue;
 	}
 	di_fini(node);
 
-	cfg = (struct libusb_config_descriptor *)dpriv->raw_cfgdescr;
+	cfg = (struct libusb_config_descriptor *)idp->idp_raw_cfgdescr;
 	len = MIN(len, libusb_le16_to_cpu(cfg->wTotalLength));
-	memcpy(buf, dpriv->raw_cfgdescr, len);
-	usbi_dbg(DEVICE_CTX(dev), "path:%s len %zu", dpriv->phypath, len);
+	memcpy(buf, idp->idp_raw_cfgdescr, len);
+	usbi_dbg(DEVICE_CTX(dev), "path:%s len %zu", idp->idp_physpath, len);
 
 	return (len);
 }
@@ -1014,9 +1196,9 @@ illumos_get_config_descriptor(struct libusb_device *dev, uint8_t idx,
 int
 illumos_get_configuration(struct libusb_device_handle *handle, uint8_t *config)
 {
-	illumos_dev_priv_t *dpriv = usbi_get_device_priv(handle->dev);
+	illumos_dev_priv_t *idp = usbi_get_device_priv(handle->dev);
 
-	*config = dpriv->cfgvalue;
+	*config = idp->idp_cfgvalue;
 
 	usbi_dbg(HANDLE_CTX(handle), "bConfigurationValue %u", *config);
 
@@ -1026,20 +1208,20 @@ illumos_get_configuration(struct libusb_device_handle *handle, uint8_t *config)
 int
 illumos_set_configuration(struct libusb_device_handle *handle, int config)
 {
-	illumos_dev_priv_t *dpriv = usbi_get_device_priv(handle->dev);
-	illumos_dev_handle_priv_t *hpriv;
+	illumos_dev_priv_t *idp = usbi_get_device_priv(handle->dev);
+	illumos_dev_handle_priv_t *ihp;
 
 	usbi_dbg(HANDLE_CTX(handle), "bConfigurationValue %d", config);
-	hpriv = usbi_get_device_handle_priv(handle);
+	ihp = usbi_get_device_handle_priv(handle);
 
-	if (dpriv->ugenpath == NULL)
+	if (idp->idp_ugenpath == NULL)
 		return (LIBUSB_ERROR_NOT_SUPPORTED);
 
 	if (config < 1)
 		return (LIBUSB_ERROR_NOT_SUPPORTED);
 
-	dpriv->cfgvalue = config;
-	hpriv->config_index = config - 1;
+	idp->idp_cfgvalue = config;
+	ihp->ihp_config_index = config - 1;
 
 	return (LIBUSB_SUCCESS);
 }
@@ -1057,12 +1239,12 @@ illumos_claim_interface(struct libusb_device_handle *handle, uint8_t iface)
 int
 illumos_release_interface(struct libusb_device_handle *handle, uint8_t iface)
 {
-	illumos_dev_handle_priv_t *hpriv = usbi_get_device_handle_priv(handle);
+	illumos_dev_handle_priv_t *ihp = usbi_get_device_handle_priv(handle);
 
 	usbi_dbg(HANDLE_CTX(handle), "iface %u", iface);
 
 	/* XXX: can we release it? */
-	hpriv->altsetting[iface] = 0;
+	ihp->ihp_altsetting[iface] = 0;
 
 	return (LIBUSB_SUCCESS);
 }
@@ -1071,38 +1253,50 @@ int
 illumos_set_interface_altsetting(struct libusb_device_handle *handle,
     uint8_t iface, uint8_t altsetting)
 {
-	illumos_dev_priv_t *dpriv = usbi_get_device_priv(handle->dev);
-	illumos_dev_handle_priv_t *hpriv = usbi_get_device_handle_priv(handle);
+	illumos_dev_priv_t *idp = usbi_get_device_priv(handle->dev);
+	illumos_dev_handle_priv_t *ihp = usbi_get_device_handle_priv(handle);
 
 	usbi_dbg(HANDLE_CTX(handle), "iface %u, setting %u", iface, altsetting);
 
-	if (dpriv->ugenpath == NULL)
+	if (idp->idp_ugenpath == NULL)
 		return (LIBUSB_ERROR_NOT_FOUND);
 
 	/* XXX: can we switch altsetting? */
-	hpriv->altsetting[iface] = altsetting;
+	ihp->ihp_altsetting[iface] = altsetting;
 
 	return (LIBUSB_SUCCESS);
 }
 
 static void
-usb_dump_data(const void *data, size_t size)
+usb_dump_data(libusb_context *ctx, const void *data, size_t size)
 {
 	const uint8_t *p = data;
-	size_t i;
+	char buf[256];
+	char *l = buf;
 
-	if (getenv("LIBUSB_DEBUG") == NULL) {
+	if (ctx->debug < LIBUSB_LOG_LEVEL_DEBUG) {
 		return;
 	}
 
-	(void) fprintf(stderr, "data dump:");
-	for (i = 0; i < size; i++) {
+	usbi_dbg(ctx, "data dump:");
+	for (size_t i = 0; i < size; i++) {
 		if (i % 16 == 0) {
-			(void) fprintf(stderr, "\n%08zx\t", i);
+			if (l != buf) {
+				usbi_dbg(ctx, "%s", buf);
+				l = buf;
+			}
+
+			l += snprintf(l, sizeof (buf) - (l - buf), "%08zx  ",
+			    i);
 		}
-		(void) fprintf(stderr, "%02x ", p[i]);
+
+		l += snprintf(l, sizeof (buf) - (l - buf), "%02x ", p[i]);
+	}
+
+	if (l != buf) {
+		l = buf;
+		usbi_dbg(ctx, "%s", buf);
 	}
-	(void) fprintf(stderr, "\n");
 }
 
 static void
@@ -1112,7 +1306,7 @@ illumos_async_callback(union sigval arg)
 	struct libusb_transfer *xfer = tpriv->transfer;
 	struct usbi_transfer *ixfer = LIBUSB_TRANSFER_TO_USBI_TRANSFER(xfer);
 	struct aiocb *aiocb = &tpriv->aiocb;
-	illumos_dev_handle_priv_t *hpriv;
+	illumos_dev_handle_priv_t *ihp;
 	uint8_t ep;
 	libusb_device_handle *dev_handle;
 
@@ -1122,7 +1316,7 @@ illumos_async_callback(union sigval arg)
 	}
 
 	if (aio_error(aiocb) != ECANCELED) {
-		hpriv = usbi_get_device_handle_priv(dev_handle);
+		ihp = usbi_get_device_handle_priv(dev_handle);
 		ep = illumos_usb_ep_index(xfer->endpoint);
 
 		/*
@@ -1130,7 +1324,7 @@ illumos_async_callback(union sigval arg)
 		 * ugen(4D) so that we can translate and report it later.
 		 */
 		tpriv->ugen_status = illumos_usb_get_status(TRANSFER_CTX(xfer),
-		    hpriv->eps[ep].statfd);
+		    ihp->ihp_eps[ep].statfd);
 	} else {
 		tpriv->ugen_status = USB_LC_STAT_NOERROR;
 	}
@@ -1143,7 +1337,7 @@ illumos_do_async_io(struct libusb_transfer *transfer)
 {
 	int ret = -1;
 	struct aiocb *aiocb;
-	illumos_dev_handle_priv_t *hpriv;
+	illumos_dev_handle_priv_t *ihp;
 	uint8_t ep;
 	illumos_xfer_priv_t *tpriv;
 
@@ -1151,14 +1345,14 @@ illumos_do_async_io(struct libusb_transfer *transfer)
 
 	tpriv = usbi_get_transfer_priv(
 	    LIBUSB_TRANSFER_TO_USBI_TRANSFER(transfer));
-	hpriv = usbi_get_device_handle_priv(transfer->dev_handle);
+	ihp = usbi_get_device_handle_priv(transfer->dev_handle);
 	ep = illumos_usb_ep_index(transfer->endpoint);
 
 	tpriv->type = ILLUMOS_XFT_AIO;
 	tpriv->transfer = transfer;
 	aiocb = &tpriv->aiocb;
 	bzero(aiocb, sizeof(*aiocb));
-	aiocb->aio_fildes = hpriv->eps[ep].datafd;
+	aiocb->aio_fildes = ihp->ihp_eps[ep].datafd;
 	aiocb->aio_buf = transfer->buffer;
 	aiocb->aio_nbytes = transfer->length;
 	aiocb->aio_lio_opcode =
@@ -1195,14 +1389,17 @@ illumos_usb_do_io(struct libusb_context *ctx, illumos_ep_priv_t *ep,
 		errno = 0;
 		ret = read(ep->datafd, data, size);
 		error = errno;
-		usb_dump_data(data, size);
+		usb_dump_data(ctx, data, size);
 		break;
 	case ILLUMOS_DIR_WRITE:
-		usb_dump_data(data, size);
+		usb_dump_data(ctx, data, size);
 		errno = 0;
 		ret = write(ep->datafd, data, size);
 		error = errno;
 		break;
+	default:
+		abort();
+		break;
 	}
 
 	/*
@@ -1215,9 +1412,9 @@ illumos_usb_do_io(struct libusb_context *ctx, illumos_ep_priv_t *ep,
 	    ret, error, tpriv->ugen_status);
 
 	if (ret < 0) {
-		usbi_dbg(ctx, "TID=%x io %s errno %d (%s)", pthread_self(),
+		usbi_err(ctx, "TID=%x io %s errno %d (%s)", pthread_self(),
 		    dir == ILLUMOS_DIR_WRITE ? "WRITE" : "READ",
-		    errno, strerror(errno));
+		    error, strerror(error));
 
 		errno = error;
 		return (-1);
@@ -1233,7 +1430,7 @@ illumos_submit_ctrl_on_default(struct libusb_transfer *xfer)
 	struct usbi_transfer *ixfer = LIBUSB_TRANSFER_TO_USBI_TRANSFER(xfer);
 	illumos_xfer_priv_t *tpriv = usbi_get_transfer_priv(ixfer);
 	struct libusb_device_handle *hdl = xfer->dev_handle;
-	illumos_dev_handle_priv_t *hpriv = usbi_get_device_handle_priv(hdl);
+	illumos_dev_handle_priv_t *ihp = usbi_get_device_handle_priv(hdl);
 	uint8_t *data = xfer->buffer;
 	size_t datalen = xfer->length;
 	illumos_iodir_t dir =
@@ -1245,8 +1442,8 @@ illumos_submit_ctrl_on_default(struct libusb_transfer *xfer)
 	tpriv->transfer = xfer;
 	tpriv->ctrl_len = 0;
 
-	if (hpriv->eps[0].datafd < 0) {
-		usbi_dbg(ctx, "ep0 not opened");
+	if (ihp->ihp_eps[0].datafd < 0) {
+		usbi_err(ctx, "ep0 not opened");
 		return (LIBUSB_ERROR_NOT_FOUND);
 	}
 
@@ -1256,7 +1453,7 @@ illumos_submit_ctrl_on_default(struct libusb_transfer *xfer)
 		 * first write(2) the USB setup data.
 		 */
 		usbi_dbg(ctx, "IN request: write setup");
-		if ((ret = illumos_usb_do_io(ctx, &hpriv->eps[0], tpriv,
+		if ((ret = illumos_usb_do_io(ctx, &ihp->ihp_eps[0], tpriv,
 		    data, LIBUSB_CONTROL_SETUP_SIZE, ILLUMOS_DIR_WRITE)) < 0) {
 			int e = errno;
 			usbi_dbg(ctx, "IN request: setup failed (%d, %s)",
@@ -1278,7 +1475,7 @@ illumos_submit_ctrl_on_default(struct libusb_transfer *xfer)
 
 	usbi_dbg(ctx, "%s request: data",
 	    dir == ILLUMOS_DIR_READ ? "IN" : "OUT");
-	ret = illumos_usb_do_io(ctx, &hpriv->eps[0], tpriv, data, datalen, dir);
+	ret = illumos_usb_do_io(ctx, &ihp->ihp_eps[0], tpriv, data, datalen, dir);
 	if (ret >= 0) {
 		tpriv->ctrl_len += ret;
 	}
@@ -1307,12 +1504,9 @@ illumos_clear_halt(struct libusb_device_handle *handle, unsigned char endpoint)
 void
 illumos_destroy_device(struct libusb_device *dev)
 {
-	illumos_dev_priv_t *dpriv = usbi_get_device_priv(dev);
-
 	usbi_dbg(DEVICE_CTX(dev), "destroy everything");
-	free(dpriv->raw_cfgdescr);
-	free(dpriv->ugenpath);
-	free(dpriv->phypath);
+
+	illumos_dev_priv_reset(usbi_get_device_priv(dev));
 }
 
 int
@@ -1372,7 +1566,7 @@ int
 illumos_cancel_transfer(struct usbi_transfer *itransfer)
 {
 	illumos_xfer_priv_t *tpriv;
-	illumos_dev_handle_priv_t *hpriv;
+	illumos_dev_handle_priv_t *ihp;
 	struct libusb_transfer *transfer;
 	struct aiocb *aiocb;
 	uint8_t ep;
@@ -1381,13 +1575,13 @@ illumos_cancel_transfer(struct usbi_transfer *itransfer)
 	tpriv = usbi_get_transfer_priv(itransfer);
 	aiocb = &tpriv->aiocb;
 	transfer = USBI_TRANSFER_TO_LIBUSB_TRANSFER(itransfer);
-	hpriv = usbi_get_device_handle_priv(transfer->dev_handle);
+	ihp = usbi_get_device_handle_priv(transfer->dev_handle);
 	ep = illumos_usb_ep_index(transfer->endpoint);
 
-	ret = aio_cancel(hpriv->eps[ep].datafd, aiocb);
+	ret = aio_cancel(ihp->ihp_eps[ep].datafd, aiocb);
 
 	usbi_dbg(ITRANSFER_CTX(itransfer), "aio->fd=%d fd=%d ret = %d, %s",
-	    aiocb->aio_fildes, hpriv->eps[ep].datafd, ret,
+	    aiocb->aio_fildes, ihp->ihp_eps[ep].datafd, ret,
 	    (ret == AIO_CANCELED) ? "AIO canceled" : strerror(errno));
 
 	if (ret != AIO_CANCELED) {
@@ -1454,7 +1648,8 @@ illumos_handle_transfer_completion(struct usbi_transfer *ixfer)
 
 		usbi_dbg(TRANSFER_CTX(xfer), "ret=%d, len=%d, actual_len=%d",
 		    ret, xfer->length, xfer->actual_length);
-		usb_dump_data(xfer->buffer, xfer->actual_length);
+		usb_dump_data(TRANSFER_CTX(xfer),
+		    xfer->buffer, xfer->actual_length);
 
 		status = LIBUSB_TRANSFER_COMPLETED;
 
@@ -1525,83 +1720,82 @@ illumos_usb_get_status(struct libusb_context *ctx, int fd)
 			usbi_dbg(ctx, "No Error");
 			break;
 		case USB_LC_STAT_CRC:
-			usbi_dbg(ctx, "CRC Timeout Detected\n");
+			usbi_dbg(ctx, "CRC Timeout Detected");
 			break;
 		case USB_LC_STAT_BITSTUFFING:
-			usbi_dbg(ctx, "Bit Stuffing Violation\n");
+			usbi_dbg(ctx, "Bit Stuffing Violation");
 			break;
 		case USB_LC_STAT_DATA_TOGGLE_MM:
-			usbi_dbg(ctx, "Data Toggle Mismatch\n");
+			usbi_dbg(ctx, "Data Toggle Mismatch");
 			break;
 		case USB_LC_STAT_STALL:
-			usbi_dbg(ctx, "End Point Stalled\n");
+			usbi_dbg(ctx, "End Point Stalled");
 			break;
 		case USB_LC_STAT_DEV_NOT_RESP:
-			usbi_dbg(ctx, "Device is Not Responding\n");
+			usbi_dbg(ctx, "Device is Not Responding");
 			break;
 		case USB_LC_STAT_PID_CHECKFAILURE:
-			usbi_dbg(ctx, "PID Check Failure\n");
+			usbi_dbg(ctx, "PID Check Failure");
 			break;
 		case USB_LC_STAT_UNEXP_PID:
-			usbi_dbg(ctx, "Unexpected PID\n");
+			usbi_dbg(ctx, "Unexpected PID");
 			break;
 		case USB_LC_STAT_DATA_OVERRUN:
-			usbi_dbg(ctx, "Data Exceeded Size\n");
+			usbi_dbg(ctx, "Data Exceeded Size");
 			break;
 		case USB_LC_STAT_DATA_UNDERRUN:
-			usbi_dbg(ctx, "Less data received\n");
+			usbi_dbg(ctx, "Less data received");
 			break;
 		case USB_LC_STAT_BUFFER_OVERRUN:
-			usbi_dbg(ctx, "Buffer Size Exceeded\n");
+			usbi_dbg(ctx, "Buffer Size Exceeded");
 			break;
 		case USB_LC_STAT_BUFFER_UNDERRUN:
-			usbi_dbg(ctx, "Buffer Underrun\n");
+			usbi_dbg(ctx, "Buffer Underrun");
 			break;
 		case USB_LC_STAT_TIMEOUT:
-			usbi_dbg(ctx, "Command Timed Out\n");
+			usbi_dbg(ctx, "Command Timed Out");
 			break;
 		case USB_LC_STAT_NOT_ACCESSED:
-			usbi_dbg(ctx, "Not Accessed by h/w\n");
+			usbi_dbg(ctx, "Not Accessed by h/w");
 			break;
 		case USB_LC_STAT_UNSPECIFIED_ERR:
-			usbi_dbg(ctx, "Unspecified Error\n");
+			usbi_dbg(ctx, "Unspecified Error");
 			break;
 		case USB_LC_STAT_NO_BANDWIDTH:
-			usbi_dbg(ctx, "No Bandwidth\n");
+			usbi_dbg(ctx, "No Bandwidth");
 			break;
 		case USB_LC_STAT_HW_ERR:
-			usbi_dbg(ctx, "Host Controller h/w Error\n");
+			usbi_dbg(ctx, "Host Controller h/w Error");
 			break;
 		case USB_LC_STAT_SUSPENDED:
-			usbi_dbg(ctx, "Device was Suspended\n");
+			usbi_dbg(ctx, "Device was Suspended");
 			break;
 		case USB_LC_STAT_DISCONNECTED:
-			usbi_dbg(ctx, "Device was Disconnected\n");
+			usbi_dbg(ctx, "Device was Disconnected");
 			break;
 		case USB_LC_STAT_INTR_BUF_FULL:
-			usbi_dbg(ctx, "Interrupt buffer was full\n");
+			usbi_dbg(ctx, "Interrupt buffer was full");
 			break;
 		case USB_LC_STAT_INVALID_REQ:
-			usbi_dbg(ctx, "Request was Invalid\n");
+			usbi_dbg(ctx, "Request was Invalid");
 			break;
 		case USB_LC_STAT_INTERRUPTED:
-			usbi_dbg(ctx, "Request was Interrupted\n");
+			usbi_dbg(ctx, "Request was Interrupted");
 			break;
 		case USB_LC_STAT_NO_RESOURCES:
 			usbi_dbg(ctx, "No resources available for "
-			    "request\n");
+			    "request");
 			break;
 		case USB_LC_STAT_INTR_POLLING_FAILED:
 			usbi_dbg(ctx, "Failed to Restart Poll");
 			break;
 		default:
-			usbi_dbg(ctx, "Error Not Determined %d\n",
-			    status);
+			usbi_err(ctx, "Error Not Determined %d", status);
 			status = USB_LC_STAT_UNSPECIFIED_ERR;
 			break;
 		}
 	} else {
-		usbi_dbg(ctx, "read stat error: (ret %ld, error %d) %s",
+		usbi_err(ctx, "read stat error: (ret %ld, error %d) %s",
 		    (long)ret, errno, strerror(errno));
 		status = USB_LC_STAT_UNSPECIFIED_ERR;
 	}
@@ -1634,8 +1828,8 @@ const struct usbi_os_backend usbi_backend = {
 	.handle_transfer_completion = illumos_handle_transfer_completion,
 
 	.device_priv_size = sizeof(illumos_dev_priv_t),
-	.device_handle_priv_size = sizeof(illumos_dev_handle_priv_t),
+	.device_handle_priv_size = sizeof (illumos_dev_handle_priv_t),
 
 	.kernel_driver_active = illumos_kernel_driver_active,
-	.transfer_priv_size = sizeof(illumos_xfer_priv_t),
+	.transfer_priv_size = sizeof (illumos_xfer_priv_t),
 };
diff --git a/libusb/os/illumos_usb.h b/libusb/os/illumos_usb.h
index 59abcca4..2f743ee3 100644
--- a/libusb/os/illumos_usb.h
+++ b/libusb/os/illumos_usb.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2016, Oracle and/or its affiliates.
- * Copyright 2022 Oxide Computer Company
+ * Copyright 2024 Oxide Computer Company
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -30,10 +30,23 @@ typedef enum illumos_iodir {
 } illumos_iodir_t;
 
 typedef struct illumos_dev_priv {
-	uint8_t	cfgvalue;		/* active config value */
-	uint8_t	*raw_cfgdescr;		/* active config descriptor */
-	char	*ugenpath;		/* name of the ugen(4) node */
-	char	*phypath;		/* physical path */
+	/*
+	 * Active configuration descriptor and value:
+	 */
+	uint8_t			*idp_raw_cfgdescr;
+	uint8_t			idp_cfgvalue;
+
+	/*
+	 * /dev path of the directory that contains the ugen(4D) minor nodes
+	 * for this device; e.g., "/dev/usb/483.3754/0".
+	 */
+	char			*idp_ugenpath;
+
+	/*
+	 * The physical /devices path of this device, without a minor node
+	 * suffix.
+	 */
+	char			*idp_physpath;
 } illumos_dev_priv_t;
 
 typedef struct illumos_ep_priv {
@@ -42,10 +55,10 @@ typedef struct illumos_ep_priv {
 } illumos_ep_priv_t;
 
 typedef struct illumos_dev_handle_priv {
-	uint8_t			altsetting[USB_MAXINTERFACES];	/* a interface's alt */
-	uint8_t			config_index;
-	illumos_ep_priv_t		eps[USB_MAXENDPOINTS];
-	illumos_dev_priv_t	*dpriv; /* device private */
+	uint8_t			ihp_altsetting[USB_MAXINTERFACES];
+	uint8_t			ihp_config_index;
+	illumos_ep_priv_t	ihp_eps[USB_MAXENDPOINTS];
+	illumos_dev_priv_t	*ihp_idp;
 } illumos_dev_handle_priv_t;
 
 typedef enum illumos_xfer_type {
@@ -63,28 +76,34 @@ typedef struct illumos_transfer_priv {
 
 #define	MAX_BUSES		256
 
-struct node_args {
-	struct libusb_context	*ctx;
-	struct discovered_devs	**discdevs;
-	const char		*last_ugenpath;
-	di_devlink_handle_t	dlink_hdl;
-	char			*buses[MAX_BUSES];
-};
+typedef struct illumos_get_device_list {
+	struct libusb_context	*gdl_ctx;
+	struct discovered_devs	**gdl_discdevs;
+	di_devlink_handle_t	gdl_devlink;
+	char			*gdl_buses[MAX_BUSES];
+	int			gdl_error;
+} illumos_get_device_list_t;
 
-struct devlink_cbarg {
-	struct node_args	*nargs;	/* di node walk arguments */
-	di_node_t		myself;	/* the di node */
-	di_minor_t		minor;
-};
+typedef struct illumos_make_session_id {
+	uint64_t		msi_session_id;
+	uint8_t			msi_bus_number;
+	int			msi_is_root_hub;
+} illumos_make_session_id_t;
+
+typedef struct illumos_gdl_find_hubs {
+	struct libusb_context	*dlfh_ctx;
+	int			dlfh_is_hub;
+} illumos_gdl_find_hubs_t;
 
-typedef struct walk_link {
-	char *path;
-	int len;
-	char **linkpp;
-} walk_link_t;
+typedef struct illumos_gdl_find_ugenpath {
+	const char		*fup_physpath;
+	int			fup_len;
+	struct libusb_device	*fup_dev;
+	illumos_dev_priv_t	fup_idp;
+} illumos_gdl_find_ugenpath_t;
 
 /* AIO callback args */
-struct aio_callback_args{
+struct aio_callback_args {
 	struct libusb_transfer *transfer;
 	struct aiocb aiocb;
 };
-- 
2.40.3

